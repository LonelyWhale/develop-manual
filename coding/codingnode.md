# 《高效程序员的45个习惯》
##### 代码要清晰地表达意图
```
PIE原则(Program Intently and Expressively)
代码必须明确说出你的意图，而且必须富有表达力。这样可以让代码更易于被别人阅读和理解。代码不让人迷惑，也就减少了发生潜在错误的可能。一言以蔽之，代码应意图清晰，表达明确。
要编写清晰的而不是讨巧的代码。向代码阅读者明确表明你的意图。可读性差的代码一点都不聪明。
```
##### 用代码沟通
```
用注释沟通。使用细心选择的、有意义的命名。用注释描述代码意图和约束。注释不能替代优秀的代码。
* 目的：为什么需要这个方法？
<summary></summary>
* 需求（前置条件）：方法需要什么样的输入，对象必须处于何种状态，才能让这个方法工作？
<param name=""></param>
* 承诺（后置条件）：方法成功执行后，对象现在处于什么状态，有哪些返回值？
<returns></returns>
* 异常：可能会发生什么样的问题？会抛出什么样的异常？
<exception cref=""></exception>
```
##### 动态评估取舍
```
考虑性能、便利性、生产力、成本和上市时间。如果性能表现足够了，就将注意力放在其他因素上。不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化。没有适宜所有状况的最佳解决方案。你必须对手上的问题进行评估，并选出最合适的解决方案。
```
##### 增量式编程
```
在很短的编辑/构建/测试循环中编写代码。
要像重构你的代码那样，重构你的测试，而且要经常重构测试。
可以使用测试优先开发方式，作为强制进行增量式编程的方式。
```
##### 保持简单
```
开发可以工作的、最简单的解决方案。
优雅的代码第一眼看上去，就知道它的用处，而且很简洁。
```
##### 编写内聚的代码
```
内聚性会影响一个组件的可重用性。组件粒度是在设计时要考虑的一个重要因素。根据重用发布等价原则：重用的粒度与发布的粒度相同。
让类的功能尽量集中，让组件尽量小。
具有良好内聚性的代码，可能会根据需求的变化，而成比例地进行变更。
```
##### 告知，不要询问
```
命令与查询相分离模式（command-query separation）。
一个常规的“命令”可能会改变对象的状态，而且有可能返回一些有用的值，以方便使用。一个“查询”仅仅提供给开发人员对象的状态，并不会对其外部的可见状态进行修改。
```
##### 根据契约进行替换
```
Liskov替换原则告诉我们：任何继承后得到的派生类对象，必须可以替换任何被使用的基类对象，而且使用者不必知道任何差异。
如果新类可以替换已有的类，并且它们之间的关系可以通过is-a来描述，就要使用继承。
如果新类只是使用已有的类，并且两者之间的关系可以描述为has-a或是uses-a，就使用委托吧。
```
##### 记录问题解决日志
```
不要在同一处跌倒两次Don't get burned twice，维护一个保存曾遇到的问题以及对应解决方案的日志。
* 问题发生日期。
* 问题简述。
* 解决方案详细描述。
* 引用文章或网址，以提供更多细节或相关信息。
* 任何代码片段、设置或对话框的截屏，只要它们是解决方案的一部分，或者可以帮助更深入地理解相关细节。
要记录团队做出一个重要决策的原因。
要记录发生问题时应用程序、应用框架或平台的特定版本。
```
##### 警告就是错误
```
要找到一种方式让编译器将警告作为错误提示出来。如果编译器允许调整警告的报告级别，那就把级别调到最高，让任何警告不能被忽略。
```
##### 对问题各个击破
```
不要试图马上了解系统的所有细节。要想认真调试，就必须将有问题的组件或模块与其他代码库分离开来。
用原型进行分离Prototype to isolate
以二分查找的方式来定位问题是很有用的。也就是说，将问题空间分为两半，看看哪一半包含问题。再将包含问题的一半进行二分，并不断重复这个过程。
```
##### 报告所有的异常
```
处理或是向上传播所有的异常。
```
##### 提供有用的错误信息
```
当发生问题时，让应用详细记录错误的相关数据。
```